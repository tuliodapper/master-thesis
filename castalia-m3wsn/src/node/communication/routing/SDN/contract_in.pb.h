// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: contract_in.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_contract_5fin_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_contract_5fin_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_contract_5fin_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_contract_5fin_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[11]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_contract_5fin_2eproto;
namespace contract_in {
class ContractIn;
class ContractInDefaultTypeInternal;
extern ContractInDefaultTypeInternal _ContractIn_default_instance_;
class ContractIn_Load;
class ContractIn_LoadDefaultTypeInternal;
extern ContractIn_LoadDefaultTypeInternal _ContractIn_Load_default_instance_;
class ContractIn_Location;
class ContractIn_LocationDefaultTypeInternal;
extern ContractIn_LocationDefaultTypeInternal _ContractIn_Location_default_instance_;
class ContractIn_NotifyStatusController;
class ContractIn_NotifyStatusControllerDefaultTypeInternal;
extern ContractIn_NotifyStatusControllerDefaultTypeInternal _ContractIn_NotifyStatusController_default_instance_;
class ContractIn_NotifyStatusRelay;
class ContractIn_NotifyStatusRelayDefaultTypeInternal;
extern ContractIn_NotifyStatusRelayDefaultTypeInternal _ContractIn_NotifyStatusRelay_default_instance_;
class ContractIn_NotifyStatusUser;
class ContractIn_NotifyStatusUserDefaultTypeInternal;
extern ContractIn_NotifyStatusUserDefaultTypeInternal _ContractIn_NotifyStatusUser_default_instance_;
class ContractIn_Register;
class ContractIn_RegisterDefaultTypeInternal;
extern ContractIn_RegisterDefaultTypeInternal _ContractIn_Register_default_instance_;
class ContractIn_Status;
class ContractIn_StatusDefaultTypeInternal;
extern ContractIn_StatusDefaultTypeInternal _ContractIn_Status_default_instance_;
class ContractIn_Telemetry;
class ContractIn_TelemetryDefaultTypeInternal;
extern ContractIn_TelemetryDefaultTypeInternal _ContractIn_Telemetry_default_instance_;
class ContractIn_TelemetryByHop;
class ContractIn_TelemetryByHopDefaultTypeInternal;
extern ContractIn_TelemetryByHopDefaultTypeInternal _ContractIn_TelemetryByHop_default_instance_;
class ContractIn_Unregister;
class ContractIn_UnregisterDefaultTypeInternal;
extern ContractIn_UnregisterDefaultTypeInternal _ContractIn_Unregister_default_instance_;
}  // namespace contract_in
PROTOBUF_NAMESPACE_OPEN
template<> ::contract_in::ContractIn* Arena::CreateMaybeMessage<::contract_in::ContractIn>(Arena*);
template<> ::contract_in::ContractIn_Load* Arena::CreateMaybeMessage<::contract_in::ContractIn_Load>(Arena*);
template<> ::contract_in::ContractIn_Location* Arena::CreateMaybeMessage<::contract_in::ContractIn_Location>(Arena*);
template<> ::contract_in::ContractIn_NotifyStatusController* Arena::CreateMaybeMessage<::contract_in::ContractIn_NotifyStatusController>(Arena*);
template<> ::contract_in::ContractIn_NotifyStatusRelay* Arena::CreateMaybeMessage<::contract_in::ContractIn_NotifyStatusRelay>(Arena*);
template<> ::contract_in::ContractIn_NotifyStatusUser* Arena::CreateMaybeMessage<::contract_in::ContractIn_NotifyStatusUser>(Arena*);
template<> ::contract_in::ContractIn_Register* Arena::CreateMaybeMessage<::contract_in::ContractIn_Register>(Arena*);
template<> ::contract_in::ContractIn_Status* Arena::CreateMaybeMessage<::contract_in::ContractIn_Status>(Arena*);
template<> ::contract_in::ContractIn_Telemetry* Arena::CreateMaybeMessage<::contract_in::ContractIn_Telemetry>(Arena*);
template<> ::contract_in::ContractIn_TelemetryByHop* Arena::CreateMaybeMessage<::contract_in::ContractIn_TelemetryByHop>(Arena*);
template<> ::contract_in::ContractIn_Unregister* Arena::CreateMaybeMessage<::contract_in::ContractIn_Unregister>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace contract_in {

enum ContractIn_ContractInPacket : int {
  ContractIn_ContractInPacket_UNREGISTER_USER = 1,
  ContractIn_ContractInPacket_NOTIFY_STATUS_RELAY = 2,
  ContractIn_ContractInPacket_REGISTER_RELAY = 3,
  ContractIn_ContractInPacket_NOTIFY_STATUS_USER = 4,
  ContractIn_ContractInPacket_REGISTER_USER = 5,
  ContractIn_ContractInPacket_REFRESH_REGISTER_USER = 6,
  ContractIn_ContractInPacket_NOTIFY_STATUS_CONTROLLER = 7,
  ContractIn_ContractInPacket_PACKET_IN = 8,
  ContractIn_ContractInPacket_REQUEST = 9,
  ContractIn_ContractInPacket_TELEMETRY = 10
};
bool ContractIn_ContractInPacket_IsValid(int value);
constexpr ContractIn_ContractInPacket ContractIn_ContractInPacket_ContractInPacket_MIN = ContractIn_ContractInPacket_UNREGISTER_USER;
constexpr ContractIn_ContractInPacket ContractIn_ContractInPacket_ContractInPacket_MAX = ContractIn_ContractInPacket_TELEMETRY;
constexpr int ContractIn_ContractInPacket_ContractInPacket_ARRAYSIZE = ContractIn_ContractInPacket_ContractInPacket_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ContractIn_ContractInPacket_descriptor();
template<typename T>
inline const std::string& ContractIn_ContractInPacket_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ContractIn_ContractInPacket>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ContractIn_ContractInPacket_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ContractIn_ContractInPacket_descriptor(), enum_t_value);
}
inline bool ContractIn_ContractInPacket_Parse(
    const std::string& name, ContractIn_ContractInPacket* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ContractIn_ContractInPacket>(
    ContractIn_ContractInPacket_descriptor(), name, value);
}
enum ContractIn_Event : int {
  ContractIn_Event_FORCED = 1,
  ContractIn_Event_REQUIRED = 2
};
bool ContractIn_Event_IsValid(int value);
constexpr ContractIn_Event ContractIn_Event_Event_MIN = ContractIn_Event_FORCED;
constexpr ContractIn_Event ContractIn_Event_Event_MAX = ContractIn_Event_REQUIRED;
constexpr int ContractIn_Event_Event_ARRAYSIZE = ContractIn_Event_Event_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ContractIn_Event_descriptor();
template<typename T>
inline const std::string& ContractIn_Event_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ContractIn_Event>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ContractIn_Event_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ContractIn_Event_descriptor(), enum_t_value);
}
inline bool ContractIn_Event_Parse(
    const std::string& name, ContractIn_Event* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ContractIn_Event>(
    ContractIn_Event_descriptor(), name, value);
}
// ===================================================================

class ContractIn_Load :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:contract_in.ContractIn.Load) */ {
 public:
  ContractIn_Load();
  virtual ~ContractIn_Load();

  ContractIn_Load(const ContractIn_Load& from);
  ContractIn_Load(ContractIn_Load&& from) noexcept
    : ContractIn_Load() {
    *this = ::std::move(from);
  }

  inline ContractIn_Load& operator=(const ContractIn_Load& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContractIn_Load& operator=(ContractIn_Load&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ContractIn_Load& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ContractIn_Load* internal_default_instance() {
    return reinterpret_cast<const ContractIn_Load*>(
               &_ContractIn_Load_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ContractIn_Load& a, ContractIn_Load& b) {
    a.Swap(&b);
  }
  inline void Swap(ContractIn_Load* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ContractIn_Load* New() const final {
    return CreateMaybeMessage<ContractIn_Load>(nullptr);
  }

  ContractIn_Load* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ContractIn_Load>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ContractIn_Load& from);
  void MergeFrom(const ContractIn_Load& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContractIn_Load* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "contract_in.ContractIn.Load";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_contract_5fin_2eproto);
    return ::descriptor_table_contract_5fin_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWaitTimePacketQueueFieldNumber = 1,
    kUserNumberFieldNumber = 2,
    kDropNumberFieldNumber = 3,
  };
  // optional string waitTimePacketQueue = 1;
  bool has_waittimepacketqueue() const;
  private:
  bool _internal_has_waittimepacketqueue() const;
  public:
  void clear_waittimepacketqueue();
  const std::string& waittimepacketqueue() const;
  void set_waittimepacketqueue(const std::string& value);
  void set_waittimepacketqueue(std::string&& value);
  void set_waittimepacketqueue(const char* value);
  void set_waittimepacketqueue(const char* value, size_t size);
  std::string* mutable_waittimepacketqueue();
  std::string* release_waittimepacketqueue();
  void set_allocated_waittimepacketqueue(std::string* waittimepacketqueue);
  private:
  const std::string& _internal_waittimepacketqueue() const;
  void _internal_set_waittimepacketqueue(const std::string& value);
  std::string* _internal_mutable_waittimepacketqueue();
  public:

  // optional int32 userNumber = 2;
  bool has_usernumber() const;
  private:
  bool _internal_has_usernumber() const;
  public:
  void clear_usernumber();
  ::PROTOBUF_NAMESPACE_ID::int32 usernumber() const;
  void set_usernumber(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_usernumber() const;
  void _internal_set_usernumber(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 dropNumber = 3;
  bool has_dropnumber() const;
  private:
  bool _internal_has_dropnumber() const;
  public:
  void clear_dropnumber();
  ::PROTOBUF_NAMESPACE_ID::int32 dropnumber() const;
  void set_dropnumber(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_dropnumber() const;
  void _internal_set_dropnumber(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:contract_in.ContractIn.Load)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr waittimepacketqueue_;
  ::PROTOBUF_NAMESPACE_ID::int32 usernumber_;
  ::PROTOBUF_NAMESPACE_ID::int32 dropnumber_;
  friend struct ::TableStruct_contract_5fin_2eproto;
};
// -------------------------------------------------------------------

class ContractIn_Location :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:contract_in.ContractIn.Location) */ {
 public:
  ContractIn_Location();
  virtual ~ContractIn_Location();

  ContractIn_Location(const ContractIn_Location& from);
  ContractIn_Location(ContractIn_Location&& from) noexcept
    : ContractIn_Location() {
    *this = ::std::move(from);
  }

  inline ContractIn_Location& operator=(const ContractIn_Location& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContractIn_Location& operator=(ContractIn_Location&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ContractIn_Location& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ContractIn_Location* internal_default_instance() {
    return reinterpret_cast<const ContractIn_Location*>(
               &_ContractIn_Location_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ContractIn_Location& a, ContractIn_Location& b) {
    a.Swap(&b);
  }
  inline void Swap(ContractIn_Location* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ContractIn_Location* New() const final {
    return CreateMaybeMessage<ContractIn_Location>(nullptr);
  }

  ContractIn_Location* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ContractIn_Location>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ContractIn_Location& from);
  void MergeFrom(const ContractIn_Location& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContractIn_Location* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "contract_in.ContractIn.Location";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_contract_5fin_2eproto);
    return ::descriptor_table_contract_5fin_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // optional string x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  const std::string& x() const;
  void set_x(const std::string& value);
  void set_x(std::string&& value);
  void set_x(const char* value);
  void set_x(const char* value, size_t size);
  std::string* mutable_x();
  std::string* release_x();
  void set_allocated_x(std::string* x);
  private:
  const std::string& _internal_x() const;
  void _internal_set_x(const std::string& value);
  std::string* _internal_mutable_x();
  public:

  // optional string y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  const std::string& y() const;
  void set_y(const std::string& value);
  void set_y(std::string&& value);
  void set_y(const char* value);
  void set_y(const char* value, size_t size);
  std::string* mutable_y();
  std::string* release_y();
  void set_allocated_y(std::string* y);
  private:
  const std::string& _internal_y() const;
  void _internal_set_y(const std::string& value);
  std::string* _internal_mutable_y();
  public:

  // @@protoc_insertion_point(class_scope:contract_in.ContractIn.Location)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr x_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr y_;
  friend struct ::TableStruct_contract_5fin_2eproto;
};
// -------------------------------------------------------------------

class ContractIn_Status :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:contract_in.ContractIn.Status) */ {
 public:
  ContractIn_Status();
  virtual ~ContractIn_Status();

  ContractIn_Status(const ContractIn_Status& from);
  ContractIn_Status(ContractIn_Status&& from) noexcept
    : ContractIn_Status() {
    *this = ::std::move(from);
  }

  inline ContractIn_Status& operator=(const ContractIn_Status& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContractIn_Status& operator=(ContractIn_Status&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ContractIn_Status& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ContractIn_Status* internal_default_instance() {
    return reinterpret_cast<const ContractIn_Status*>(
               &_ContractIn_Status_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ContractIn_Status& a, ContractIn_Status& b) {
    a.Swap(&b);
  }
  inline void Swap(ContractIn_Status* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ContractIn_Status* New() const final {
    return CreateMaybeMessage<ContractIn_Status>(nullptr);
  }

  ContractIn_Status* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ContractIn_Status>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ContractIn_Status& from);
  void MergeFrom(const ContractIn_Status& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContractIn_Status* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "contract_in.ContractIn.Status";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_contract_5fin_2eproto);
    return ::descriptor_table_contract_5fin_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationFieldNumber = 1,
  };
  // optional .contract_in.ContractIn.Location location = 1;
  bool has_location() const;
  private:
  bool _internal_has_location() const;
  public:
  void clear_location();
  const ::contract_in::ContractIn_Location& location() const;
  ::contract_in::ContractIn_Location* release_location();
  ::contract_in::ContractIn_Location* mutable_location();
  void set_allocated_location(::contract_in::ContractIn_Location* location);
  private:
  const ::contract_in::ContractIn_Location& _internal_location() const;
  ::contract_in::ContractIn_Location* _internal_mutable_location();
  public:

  // @@protoc_insertion_point(class_scope:contract_in.ContractIn.Status)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::contract_in::ContractIn_Location* location_;
  friend struct ::TableStruct_contract_5fin_2eproto;
};
// -------------------------------------------------------------------

class ContractIn_NotifyStatusController :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:contract_in.ContractIn.NotifyStatusController) */ {
 public:
  ContractIn_NotifyStatusController();
  virtual ~ContractIn_NotifyStatusController();

  ContractIn_NotifyStatusController(const ContractIn_NotifyStatusController& from);
  ContractIn_NotifyStatusController(ContractIn_NotifyStatusController&& from) noexcept
    : ContractIn_NotifyStatusController() {
    *this = ::std::move(from);
  }

  inline ContractIn_NotifyStatusController& operator=(const ContractIn_NotifyStatusController& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContractIn_NotifyStatusController& operator=(ContractIn_NotifyStatusController&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ContractIn_NotifyStatusController& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ContractIn_NotifyStatusController* internal_default_instance() {
    return reinterpret_cast<const ContractIn_NotifyStatusController*>(
               &_ContractIn_NotifyStatusController_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ContractIn_NotifyStatusController& a, ContractIn_NotifyStatusController& b) {
    a.Swap(&b);
  }
  inline void Swap(ContractIn_NotifyStatusController* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ContractIn_NotifyStatusController* New() const final {
    return CreateMaybeMessage<ContractIn_NotifyStatusController>(nullptr);
  }

  ContractIn_NotifyStatusController* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ContractIn_NotifyStatusController>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ContractIn_NotifyStatusController& from);
  void MergeFrom(const ContractIn_NotifyStatusController& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContractIn_NotifyStatusController* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "contract_in.ContractIn.NotifyStatusController";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_contract_5fin_2eproto);
    return ::descriptor_table_contract_5fin_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // optional .contract_in.ContractIn.Status status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::contract_in::ContractIn_Status& status() const;
  ::contract_in::ContractIn_Status* release_status();
  ::contract_in::ContractIn_Status* mutable_status();
  void set_allocated_status(::contract_in::ContractIn_Status* status);
  private:
  const ::contract_in::ContractIn_Status& _internal_status() const;
  ::contract_in::ContractIn_Status* _internal_mutable_status();
  public:

  // @@protoc_insertion_point(class_scope:contract_in.ContractIn.NotifyStatusController)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::contract_in::ContractIn_Status* status_;
  friend struct ::TableStruct_contract_5fin_2eproto;
};
// -------------------------------------------------------------------

class ContractIn_NotifyStatusUser :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:contract_in.ContractIn.NotifyStatusUser) */ {
 public:
  ContractIn_NotifyStatusUser();
  virtual ~ContractIn_NotifyStatusUser();

  ContractIn_NotifyStatusUser(const ContractIn_NotifyStatusUser& from);
  ContractIn_NotifyStatusUser(ContractIn_NotifyStatusUser&& from) noexcept
    : ContractIn_NotifyStatusUser() {
    *this = ::std::move(from);
  }

  inline ContractIn_NotifyStatusUser& operator=(const ContractIn_NotifyStatusUser& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContractIn_NotifyStatusUser& operator=(ContractIn_NotifyStatusUser&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ContractIn_NotifyStatusUser& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ContractIn_NotifyStatusUser* internal_default_instance() {
    return reinterpret_cast<const ContractIn_NotifyStatusUser*>(
               &_ContractIn_NotifyStatusUser_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ContractIn_NotifyStatusUser& a, ContractIn_NotifyStatusUser& b) {
    a.Swap(&b);
  }
  inline void Swap(ContractIn_NotifyStatusUser* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ContractIn_NotifyStatusUser* New() const final {
    return CreateMaybeMessage<ContractIn_NotifyStatusUser>(nullptr);
  }

  ContractIn_NotifyStatusUser* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ContractIn_NotifyStatusUser>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ContractIn_NotifyStatusUser& from);
  void MergeFrom(const ContractIn_NotifyStatusUser& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContractIn_NotifyStatusUser* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "contract_in.ContractIn.NotifyStatusUser";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_contract_5fin_2eproto);
    return ::descriptor_table_contract_5fin_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // optional .contract_in.ContractIn.Status status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::contract_in::ContractIn_Status& status() const;
  ::contract_in::ContractIn_Status* release_status();
  ::contract_in::ContractIn_Status* mutable_status();
  void set_allocated_status(::contract_in::ContractIn_Status* status);
  private:
  const ::contract_in::ContractIn_Status& _internal_status() const;
  ::contract_in::ContractIn_Status* _internal_mutable_status();
  public:

  // @@protoc_insertion_point(class_scope:contract_in.ContractIn.NotifyStatusUser)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::contract_in::ContractIn_Status* status_;
  friend struct ::TableStruct_contract_5fin_2eproto;
};
// -------------------------------------------------------------------

class ContractIn_NotifyStatusRelay :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:contract_in.ContractIn.NotifyStatusRelay) */ {
 public:
  ContractIn_NotifyStatusRelay();
  virtual ~ContractIn_NotifyStatusRelay();

  ContractIn_NotifyStatusRelay(const ContractIn_NotifyStatusRelay& from);
  ContractIn_NotifyStatusRelay(ContractIn_NotifyStatusRelay&& from) noexcept
    : ContractIn_NotifyStatusRelay() {
    *this = ::std::move(from);
  }

  inline ContractIn_NotifyStatusRelay& operator=(const ContractIn_NotifyStatusRelay& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContractIn_NotifyStatusRelay& operator=(ContractIn_NotifyStatusRelay&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ContractIn_NotifyStatusRelay& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ContractIn_NotifyStatusRelay* internal_default_instance() {
    return reinterpret_cast<const ContractIn_NotifyStatusRelay*>(
               &_ContractIn_NotifyStatusRelay_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ContractIn_NotifyStatusRelay& a, ContractIn_NotifyStatusRelay& b) {
    a.Swap(&b);
  }
  inline void Swap(ContractIn_NotifyStatusRelay* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ContractIn_NotifyStatusRelay* New() const final {
    return CreateMaybeMessage<ContractIn_NotifyStatusRelay>(nullptr);
  }

  ContractIn_NotifyStatusRelay* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ContractIn_NotifyStatusRelay>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ContractIn_NotifyStatusRelay& from);
  void MergeFrom(const ContractIn_NotifyStatusRelay& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContractIn_NotifyStatusRelay* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "contract_in.ContractIn.NotifyStatusRelay";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_contract_5fin_2eproto);
    return ::descriptor_table_contract_5fin_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // optional .contract_in.ContractIn.Status status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::contract_in::ContractIn_Status& status() const;
  ::contract_in::ContractIn_Status* release_status();
  ::contract_in::ContractIn_Status* mutable_status();
  void set_allocated_status(::contract_in::ContractIn_Status* status);
  private:
  const ::contract_in::ContractIn_Status& _internal_status() const;
  ::contract_in::ContractIn_Status* _internal_mutable_status();
  public:

  // @@protoc_insertion_point(class_scope:contract_in.ContractIn.NotifyStatusRelay)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::contract_in::ContractIn_Status* status_;
  friend struct ::TableStruct_contract_5fin_2eproto;
};
// -------------------------------------------------------------------

class ContractIn_Unregister :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:contract_in.ContractIn.Unregister) */ {
 public:
  ContractIn_Unregister();
  virtual ~ContractIn_Unregister();

  ContractIn_Unregister(const ContractIn_Unregister& from);
  ContractIn_Unregister(ContractIn_Unregister&& from) noexcept
    : ContractIn_Unregister() {
    *this = ::std::move(from);
  }

  inline ContractIn_Unregister& operator=(const ContractIn_Unregister& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContractIn_Unregister& operator=(ContractIn_Unregister&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ContractIn_Unregister& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ContractIn_Unregister* internal_default_instance() {
    return reinterpret_cast<const ContractIn_Unregister*>(
               &_ContractIn_Unregister_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ContractIn_Unregister& a, ContractIn_Unregister& b) {
    a.Swap(&b);
  }
  inline void Swap(ContractIn_Unregister* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ContractIn_Unregister* New() const final {
    return CreateMaybeMessage<ContractIn_Unregister>(nullptr);
  }

  ContractIn_Unregister* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ContractIn_Unregister>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ContractIn_Unregister& from);
  void MergeFrom(const ContractIn_Unregister& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContractIn_Unregister* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "contract_in.ContractIn.Unregister";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_contract_5fin_2eproto);
    return ::descriptor_table_contract_5fin_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventFieldNumber = 1,
  };
  // optional .contract_in.ContractIn.Event event = 1;
  bool has_event() const;
  private:
  bool _internal_has_event() const;
  public:
  void clear_event();
  ::contract_in::ContractIn_Event event() const;
  void set_event(::contract_in::ContractIn_Event value);
  private:
  ::contract_in::ContractIn_Event _internal_event() const;
  void _internal_set_event(::contract_in::ContractIn_Event value);
  public:

  // @@protoc_insertion_point(class_scope:contract_in.ContractIn.Unregister)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int event_;
  friend struct ::TableStruct_contract_5fin_2eproto;
};
// -------------------------------------------------------------------

class ContractIn_Register :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:contract_in.ContractIn.Register) */ {
 public:
  ContractIn_Register();
  virtual ~ContractIn_Register();

  ContractIn_Register(const ContractIn_Register& from);
  ContractIn_Register(ContractIn_Register&& from) noexcept
    : ContractIn_Register() {
    *this = ::std::move(from);
  }

  inline ContractIn_Register& operator=(const ContractIn_Register& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContractIn_Register& operator=(ContractIn_Register&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ContractIn_Register& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ContractIn_Register* internal_default_instance() {
    return reinterpret_cast<const ContractIn_Register*>(
               &_ContractIn_Register_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ContractIn_Register& a, ContractIn_Register& b) {
    a.Swap(&b);
  }
  inline void Swap(ContractIn_Register* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ContractIn_Register* New() const final {
    return CreateMaybeMessage<ContractIn_Register>(nullptr);
  }

  ContractIn_Register* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ContractIn_Register>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ContractIn_Register& from);
  void MergeFrom(const ContractIn_Register& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContractIn_Register* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "contract_in.ContractIn.Register";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_contract_5fin_2eproto);
    return ::descriptor_table_contract_5fin_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
    kLoadFieldNumber = 2,
  };
  // optional .contract_in.ContractIn.Status status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::contract_in::ContractIn_Status& status() const;
  ::contract_in::ContractIn_Status* release_status();
  ::contract_in::ContractIn_Status* mutable_status();
  void set_allocated_status(::contract_in::ContractIn_Status* status);
  private:
  const ::contract_in::ContractIn_Status& _internal_status() const;
  ::contract_in::ContractIn_Status* _internal_mutable_status();
  public:

  // optional .contract_in.ContractIn.Load load = 2;
  bool has_load() const;
  private:
  bool _internal_has_load() const;
  public:
  void clear_load();
  const ::contract_in::ContractIn_Load& load() const;
  ::contract_in::ContractIn_Load* release_load();
  ::contract_in::ContractIn_Load* mutable_load();
  void set_allocated_load(::contract_in::ContractIn_Load* load);
  private:
  const ::contract_in::ContractIn_Load& _internal_load() const;
  ::contract_in::ContractIn_Load* _internal_mutable_load();
  public:

  // @@protoc_insertion_point(class_scope:contract_in.ContractIn.Register)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::contract_in::ContractIn_Status* status_;
  ::contract_in::ContractIn_Load* load_;
  friend struct ::TableStruct_contract_5fin_2eproto;
};
// -------------------------------------------------------------------

class ContractIn_TelemetryByHop :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:contract_in.ContractIn.TelemetryByHop) */ {
 public:
  ContractIn_TelemetryByHop();
  virtual ~ContractIn_TelemetryByHop();

  ContractIn_TelemetryByHop(const ContractIn_TelemetryByHop& from);
  ContractIn_TelemetryByHop(ContractIn_TelemetryByHop&& from) noexcept
    : ContractIn_TelemetryByHop() {
    *this = ::std::move(from);
  }

  inline ContractIn_TelemetryByHop& operator=(const ContractIn_TelemetryByHop& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContractIn_TelemetryByHop& operator=(ContractIn_TelemetryByHop&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ContractIn_TelemetryByHop& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ContractIn_TelemetryByHop* internal_default_instance() {
    return reinterpret_cast<const ContractIn_TelemetryByHop*>(
               &_ContractIn_TelemetryByHop_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ContractIn_TelemetryByHop& a, ContractIn_TelemetryByHop& b) {
    a.Swap(&b);
  }
  inline void Swap(ContractIn_TelemetryByHop* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ContractIn_TelemetryByHop* New() const final {
    return CreateMaybeMessage<ContractIn_TelemetryByHop>(nullptr);
  }

  ContractIn_TelemetryByHop* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ContractIn_TelemetryByHop>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ContractIn_TelemetryByHop& from);
  void MergeFrom(const ContractIn_TelemetryByHop& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContractIn_TelemetryByHop* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "contract_in.ContractIn.TelemetryByHop";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_contract_5fin_2eproto);
    return ::descriptor_table_contract_5fin_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimeReceivedFieldNumber = 2,
    kRssiFieldNumber = 7,
    kRelayIdFieldNumber = 1,
    kLenQueueMacFieldNumber = 3,
    kLenQueueNetFieldNumber = 4,
    kPacketDropMacFieldNumber = 5,
    kPacketDropNetFieldNumber = 6,
  };
  // optional string timeReceived = 2;
  bool has_timereceived() const;
  private:
  bool _internal_has_timereceived() const;
  public:
  void clear_timereceived();
  const std::string& timereceived() const;
  void set_timereceived(const std::string& value);
  void set_timereceived(std::string&& value);
  void set_timereceived(const char* value);
  void set_timereceived(const char* value, size_t size);
  std::string* mutable_timereceived();
  std::string* release_timereceived();
  void set_allocated_timereceived(std::string* timereceived);
  private:
  const std::string& _internal_timereceived() const;
  void _internal_set_timereceived(const std::string& value);
  std::string* _internal_mutable_timereceived();
  public:

  // optional string rssi = 7;
  bool has_rssi() const;
  private:
  bool _internal_has_rssi() const;
  public:
  void clear_rssi();
  const std::string& rssi() const;
  void set_rssi(const std::string& value);
  void set_rssi(std::string&& value);
  void set_rssi(const char* value);
  void set_rssi(const char* value, size_t size);
  std::string* mutable_rssi();
  std::string* release_rssi();
  void set_allocated_rssi(std::string* rssi);
  private:
  const std::string& _internal_rssi() const;
  void _internal_set_rssi(const std::string& value);
  std::string* _internal_mutable_rssi();
  public:

  // optional int32 relayId = 1;
  bool has_relayid() const;
  private:
  bool _internal_has_relayid() const;
  public:
  void clear_relayid();
  ::PROTOBUF_NAMESPACE_ID::int32 relayid() const;
  void set_relayid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_relayid() const;
  void _internal_set_relayid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 lenQueueMac = 3;
  bool has_lenqueuemac() const;
  private:
  bool _internal_has_lenqueuemac() const;
  public:
  void clear_lenqueuemac();
  ::PROTOBUF_NAMESPACE_ID::int32 lenqueuemac() const;
  void set_lenqueuemac(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_lenqueuemac() const;
  void _internal_set_lenqueuemac(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 lenQueueNet = 4;
  bool has_lenqueuenet() const;
  private:
  bool _internal_has_lenqueuenet() const;
  public:
  void clear_lenqueuenet();
  ::PROTOBUF_NAMESPACE_ID::int32 lenqueuenet() const;
  void set_lenqueuenet(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_lenqueuenet() const;
  void _internal_set_lenqueuenet(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 packetDropMac = 5;
  bool has_packetdropmac() const;
  private:
  bool _internal_has_packetdropmac() const;
  public:
  void clear_packetdropmac();
  ::PROTOBUF_NAMESPACE_ID::int32 packetdropmac() const;
  void set_packetdropmac(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_packetdropmac() const;
  void _internal_set_packetdropmac(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 packetDropNet = 6;
  bool has_packetdropnet() const;
  private:
  bool _internal_has_packetdropnet() const;
  public:
  void clear_packetdropnet();
  ::PROTOBUF_NAMESPACE_ID::int32 packetdropnet() const;
  void set_packetdropnet(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_packetdropnet() const;
  void _internal_set_packetdropnet(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:contract_in.ContractIn.TelemetryByHop)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr timereceived_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rssi_;
  ::PROTOBUF_NAMESPACE_ID::int32 relayid_;
  ::PROTOBUF_NAMESPACE_ID::int32 lenqueuemac_;
  ::PROTOBUF_NAMESPACE_ID::int32 lenqueuenet_;
  ::PROTOBUF_NAMESPACE_ID::int32 packetdropmac_;
  ::PROTOBUF_NAMESPACE_ID::int32 packetdropnet_;
  friend struct ::TableStruct_contract_5fin_2eproto;
};
// -------------------------------------------------------------------

class ContractIn_Telemetry :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:contract_in.ContractIn.Telemetry) */ {
 public:
  ContractIn_Telemetry();
  virtual ~ContractIn_Telemetry();

  ContractIn_Telemetry(const ContractIn_Telemetry& from);
  ContractIn_Telemetry(ContractIn_Telemetry&& from) noexcept
    : ContractIn_Telemetry() {
    *this = ::std::move(from);
  }

  inline ContractIn_Telemetry& operator=(const ContractIn_Telemetry& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContractIn_Telemetry& operator=(ContractIn_Telemetry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ContractIn_Telemetry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ContractIn_Telemetry* internal_default_instance() {
    return reinterpret_cast<const ContractIn_Telemetry*>(
               &_ContractIn_Telemetry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ContractIn_Telemetry& a, ContractIn_Telemetry& b) {
    a.Swap(&b);
  }
  inline void Swap(ContractIn_Telemetry* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ContractIn_Telemetry* New() const final {
    return CreateMaybeMessage<ContractIn_Telemetry>(nullptr);
  }

  ContractIn_Telemetry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ContractIn_Telemetry>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ContractIn_Telemetry& from);
  void MergeFrom(const ContractIn_Telemetry& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContractIn_Telemetry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "contract_in.ContractIn.Telemetry";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_contract_5fin_2eproto);
    return ::descriptor_table_contract_5fin_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgTelemetryByHopFieldNumber = 6,
    kSourceFieldNumber = 1,
    kDestinationFieldNumber = 2,
    kMessageTypeFieldNumber = 3,
    kSizeFieldNumber = 4,
    kIdVideoFieldNumber = 5,
  };
  // repeated .contract_in.ContractIn.TelemetryByHop msgTelemetryByHop = 6;
  int msgtelemetrybyhop_size() const;
  private:
  int _internal_msgtelemetrybyhop_size() const;
  public:
  void clear_msgtelemetrybyhop();
  ::contract_in::ContractIn_TelemetryByHop* mutable_msgtelemetrybyhop(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::contract_in::ContractIn_TelemetryByHop >*
      mutable_msgtelemetrybyhop();
  private:
  const ::contract_in::ContractIn_TelemetryByHop& _internal_msgtelemetrybyhop(int index) const;
  ::contract_in::ContractIn_TelemetryByHop* _internal_add_msgtelemetrybyhop();
  public:
  const ::contract_in::ContractIn_TelemetryByHop& msgtelemetrybyhop(int index) const;
  ::contract_in::ContractIn_TelemetryByHop* add_msgtelemetrybyhop();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::contract_in::ContractIn_TelemetryByHop >&
      msgtelemetrybyhop() const;

  // optional int32 source = 1;
  bool has_source() const;
  private:
  bool _internal_has_source() const;
  public:
  void clear_source();
  ::PROTOBUF_NAMESPACE_ID::int32 source() const;
  void set_source(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_source() const;
  void _internal_set_source(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 destination = 2;
  bool has_destination() const;
  private:
  bool _internal_has_destination() const;
  public:
  void clear_destination();
  ::PROTOBUF_NAMESPACE_ID::int32 destination() const;
  void set_destination(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_destination() const;
  void _internal_set_destination(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 messageType = 3;
  bool has_messagetype() const;
  private:
  bool _internal_has_messagetype() const;
  public:
  void clear_messagetype();
  ::PROTOBUF_NAMESPACE_ID::int32 messagetype() const;
  void set_messagetype(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_messagetype() const;
  void _internal_set_messagetype(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 size = 4;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  ::PROTOBUF_NAMESPACE_ID::int32 size() const;
  void set_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_size() const;
  void _internal_set_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 idVideo = 5;
  bool has_idvideo() const;
  private:
  bool _internal_has_idvideo() const;
  public:
  void clear_idvideo();
  ::PROTOBUF_NAMESPACE_ID::int32 idvideo() const;
  void set_idvideo(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_idvideo() const;
  void _internal_set_idvideo(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:contract_in.ContractIn.Telemetry)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::contract_in::ContractIn_TelemetryByHop > msgtelemetrybyhop_;
  ::PROTOBUF_NAMESPACE_ID::int32 source_;
  ::PROTOBUF_NAMESPACE_ID::int32 destination_;
  ::PROTOBUF_NAMESPACE_ID::int32 messagetype_;
  ::PROTOBUF_NAMESPACE_ID::int32 size_;
  ::PROTOBUF_NAMESPACE_ID::int32 idvideo_;
  friend struct ::TableStruct_contract_5fin_2eproto;
};
// -------------------------------------------------------------------

class ContractIn :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:contract_in.ContractIn) */ {
 public:
  ContractIn();
  virtual ~ContractIn();

  ContractIn(const ContractIn& from);
  ContractIn(ContractIn&& from) noexcept
    : ContractIn() {
    *this = ::std::move(from);
  }

  inline ContractIn& operator=(const ContractIn& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContractIn& operator=(ContractIn&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ContractIn& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ContractIn* internal_default_instance() {
    return reinterpret_cast<const ContractIn*>(
               &_ContractIn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ContractIn& a, ContractIn& b) {
    a.Swap(&b);
  }
  inline void Swap(ContractIn* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ContractIn* New() const final {
    return CreateMaybeMessage<ContractIn>(nullptr);
  }

  ContractIn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ContractIn>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ContractIn& from);
  void MergeFrom(const ContractIn& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContractIn* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "contract_in.ContractIn";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_contract_5fin_2eproto);
    return ::descriptor_table_contract_5fin_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ContractIn_Load Load;
  typedef ContractIn_Location Location;
  typedef ContractIn_Status Status;
  typedef ContractIn_NotifyStatusController NotifyStatusController;
  typedef ContractIn_NotifyStatusUser NotifyStatusUser;
  typedef ContractIn_NotifyStatusRelay NotifyStatusRelay;
  typedef ContractIn_Unregister Unregister;
  typedef ContractIn_Register Register;
  typedef ContractIn_TelemetryByHop TelemetryByHop;
  typedef ContractIn_Telemetry Telemetry;

  typedef ContractIn_ContractInPacket ContractInPacket;
  static constexpr ContractInPacket UNREGISTER_USER =
    ContractIn_ContractInPacket_UNREGISTER_USER;
  static constexpr ContractInPacket NOTIFY_STATUS_RELAY =
    ContractIn_ContractInPacket_NOTIFY_STATUS_RELAY;
  static constexpr ContractInPacket REGISTER_RELAY =
    ContractIn_ContractInPacket_REGISTER_RELAY;
  static constexpr ContractInPacket NOTIFY_STATUS_USER =
    ContractIn_ContractInPacket_NOTIFY_STATUS_USER;
  static constexpr ContractInPacket REGISTER_USER =
    ContractIn_ContractInPacket_REGISTER_USER;
  static constexpr ContractInPacket REFRESH_REGISTER_USER =
    ContractIn_ContractInPacket_REFRESH_REGISTER_USER;
  static constexpr ContractInPacket NOTIFY_STATUS_CONTROLLER =
    ContractIn_ContractInPacket_NOTIFY_STATUS_CONTROLLER;
  static constexpr ContractInPacket PACKET_IN =
    ContractIn_ContractInPacket_PACKET_IN;
  static constexpr ContractInPacket REQUEST =
    ContractIn_ContractInPacket_REQUEST;
  static constexpr ContractInPacket TELEMETRY =
    ContractIn_ContractInPacket_TELEMETRY;
  static inline bool ContractInPacket_IsValid(int value) {
    return ContractIn_ContractInPacket_IsValid(value);
  }
  static constexpr ContractInPacket ContractInPacket_MIN =
    ContractIn_ContractInPacket_ContractInPacket_MIN;
  static constexpr ContractInPacket ContractInPacket_MAX =
    ContractIn_ContractInPacket_ContractInPacket_MAX;
  static constexpr int ContractInPacket_ARRAYSIZE =
    ContractIn_ContractInPacket_ContractInPacket_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ContractInPacket_descriptor() {
    return ContractIn_ContractInPacket_descriptor();
  }
  template<typename T>
  static inline const std::string& ContractInPacket_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ContractInPacket>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ContractInPacket_Name.");
    return ContractIn_ContractInPacket_Name(enum_t_value);
  }
  static inline bool ContractInPacket_Parse(const std::string& name,
      ContractInPacket* value) {
    return ContractIn_ContractInPacket_Parse(name, value);
  }

  typedef ContractIn_Event Event;
  static constexpr Event FORCED =
    ContractIn_Event_FORCED;
  static constexpr Event REQUIRED =
    ContractIn_Event_REQUIRED;
  static inline bool Event_IsValid(int value) {
    return ContractIn_Event_IsValid(value);
  }
  static constexpr Event Event_MIN =
    ContractIn_Event_Event_MIN;
  static constexpr Event Event_MAX =
    ContractIn_Event_Event_MAX;
  static constexpr int Event_ARRAYSIZE =
    ContractIn_Event_Event_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Event_descriptor() {
    return ContractIn_Event_descriptor();
  }
  template<typename T>
  static inline const std::string& Event_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Event>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Event_Name.");
    return ContractIn_Event_Name(enum_t_value);
  }
  static inline bool Event_Parse(const std::string& name,
      Event* value) {
    return ContractIn_Event_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTimeFieldNumber = 1,
    kMsgNotifyStatusControllerFieldNumber = 5,
    kMsgNotifyStatusUserFieldNumber = 6,
    kMsgNotifyStatusRelayFieldNumber = 7,
    kMsgUnregisterFieldNumber = 8,
    kMsgRegisterFieldNumber = 9,
    kMsgTelemetryFieldNumber = 10,
    kUserIdFieldNumber = 2,
    kRelayIdFieldNumber = 3,
    kContractInPacketFieldNumber = 4,
  };
  // optional string time = 1;
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  const std::string& time() const;
  void set_time(const std::string& value);
  void set_time(std::string&& value);
  void set_time(const char* value);
  void set_time(const char* value, size_t size);
  std::string* mutable_time();
  std::string* release_time();
  void set_allocated_time(std::string* time);
  private:
  const std::string& _internal_time() const;
  void _internal_set_time(const std::string& value);
  std::string* _internal_mutable_time();
  public:

  // optional .contract_in.ContractIn.NotifyStatusController msgNotifyStatusController = 5;
  bool has_msgnotifystatuscontroller() const;
  private:
  bool _internal_has_msgnotifystatuscontroller() const;
  public:
  void clear_msgnotifystatuscontroller();
  const ::contract_in::ContractIn_NotifyStatusController& msgnotifystatuscontroller() const;
  ::contract_in::ContractIn_NotifyStatusController* release_msgnotifystatuscontroller();
  ::contract_in::ContractIn_NotifyStatusController* mutable_msgnotifystatuscontroller();
  void set_allocated_msgnotifystatuscontroller(::contract_in::ContractIn_NotifyStatusController* msgnotifystatuscontroller);
  private:
  const ::contract_in::ContractIn_NotifyStatusController& _internal_msgnotifystatuscontroller() const;
  ::contract_in::ContractIn_NotifyStatusController* _internal_mutable_msgnotifystatuscontroller();
  public:

  // optional .contract_in.ContractIn.NotifyStatusUser msgNotifyStatusUser = 6;
  bool has_msgnotifystatususer() const;
  private:
  bool _internal_has_msgnotifystatususer() const;
  public:
  void clear_msgnotifystatususer();
  const ::contract_in::ContractIn_NotifyStatusUser& msgnotifystatususer() const;
  ::contract_in::ContractIn_NotifyStatusUser* release_msgnotifystatususer();
  ::contract_in::ContractIn_NotifyStatusUser* mutable_msgnotifystatususer();
  void set_allocated_msgnotifystatususer(::contract_in::ContractIn_NotifyStatusUser* msgnotifystatususer);
  private:
  const ::contract_in::ContractIn_NotifyStatusUser& _internal_msgnotifystatususer() const;
  ::contract_in::ContractIn_NotifyStatusUser* _internal_mutable_msgnotifystatususer();
  public:

  // optional .contract_in.ContractIn.NotifyStatusRelay msgNotifyStatusRelay = 7;
  bool has_msgnotifystatusrelay() const;
  private:
  bool _internal_has_msgnotifystatusrelay() const;
  public:
  void clear_msgnotifystatusrelay();
  const ::contract_in::ContractIn_NotifyStatusRelay& msgnotifystatusrelay() const;
  ::contract_in::ContractIn_NotifyStatusRelay* release_msgnotifystatusrelay();
  ::contract_in::ContractIn_NotifyStatusRelay* mutable_msgnotifystatusrelay();
  void set_allocated_msgnotifystatusrelay(::contract_in::ContractIn_NotifyStatusRelay* msgnotifystatusrelay);
  private:
  const ::contract_in::ContractIn_NotifyStatusRelay& _internal_msgnotifystatusrelay() const;
  ::contract_in::ContractIn_NotifyStatusRelay* _internal_mutable_msgnotifystatusrelay();
  public:

  // optional .contract_in.ContractIn.Unregister msgUnregister = 8;
  bool has_msgunregister() const;
  private:
  bool _internal_has_msgunregister() const;
  public:
  void clear_msgunregister();
  const ::contract_in::ContractIn_Unregister& msgunregister() const;
  ::contract_in::ContractIn_Unregister* release_msgunregister();
  ::contract_in::ContractIn_Unregister* mutable_msgunregister();
  void set_allocated_msgunregister(::contract_in::ContractIn_Unregister* msgunregister);
  private:
  const ::contract_in::ContractIn_Unregister& _internal_msgunregister() const;
  ::contract_in::ContractIn_Unregister* _internal_mutable_msgunregister();
  public:

  // optional .contract_in.ContractIn.Register msgRegister = 9;
  bool has_msgregister() const;
  private:
  bool _internal_has_msgregister() const;
  public:
  void clear_msgregister();
  const ::contract_in::ContractIn_Register& msgregister() const;
  ::contract_in::ContractIn_Register* release_msgregister();
  ::contract_in::ContractIn_Register* mutable_msgregister();
  void set_allocated_msgregister(::contract_in::ContractIn_Register* msgregister);
  private:
  const ::contract_in::ContractIn_Register& _internal_msgregister() const;
  ::contract_in::ContractIn_Register* _internal_mutable_msgregister();
  public:

  // optional .contract_in.ContractIn.Telemetry msgTelemetry = 10;
  bool has_msgtelemetry() const;
  private:
  bool _internal_has_msgtelemetry() const;
  public:
  void clear_msgtelemetry();
  const ::contract_in::ContractIn_Telemetry& msgtelemetry() const;
  ::contract_in::ContractIn_Telemetry* release_msgtelemetry();
  ::contract_in::ContractIn_Telemetry* mutable_msgtelemetry();
  void set_allocated_msgtelemetry(::contract_in::ContractIn_Telemetry* msgtelemetry);
  private:
  const ::contract_in::ContractIn_Telemetry& _internal_msgtelemetry() const;
  ::contract_in::ContractIn_Telemetry* _internal_mutable_msgtelemetry();
  public:

  // optional int32 userId = 2;
  bool has_userid() const;
  private:
  bool _internal_has_userid() const;
  public:
  void clear_userid();
  ::PROTOBUF_NAMESPACE_ID::int32 userid() const;
  void set_userid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_userid() const;
  void _internal_set_userid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 relayId = 3;
  bool has_relayid() const;
  private:
  bool _internal_has_relayid() const;
  public:
  void clear_relayid();
  ::PROTOBUF_NAMESPACE_ID::int32 relayid() const;
  void set_relayid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_relayid() const;
  void _internal_set_relayid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required .contract_in.ContractIn.ContractInPacket contractInPacket = 4;
  bool has_contractinpacket() const;
  private:
  bool _internal_has_contractinpacket() const;
  public:
  void clear_contractinpacket();
  ::contract_in::ContractIn_ContractInPacket contractinpacket() const;
  void set_contractinpacket(::contract_in::ContractIn_ContractInPacket value);
  private:
  ::contract_in::ContractIn_ContractInPacket _internal_contractinpacket() const;
  void _internal_set_contractinpacket(::contract_in::ContractIn_ContractInPacket value);
  public:

  // @@protoc_insertion_point(class_scope:contract_in.ContractIn)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr time_;
  ::contract_in::ContractIn_NotifyStatusController* msgnotifystatuscontroller_;
  ::contract_in::ContractIn_NotifyStatusUser* msgnotifystatususer_;
  ::contract_in::ContractIn_NotifyStatusRelay* msgnotifystatusrelay_;
  ::contract_in::ContractIn_Unregister* msgunregister_;
  ::contract_in::ContractIn_Register* msgregister_;
  ::contract_in::ContractIn_Telemetry* msgtelemetry_;
  ::PROTOBUF_NAMESPACE_ID::int32 userid_;
  ::PROTOBUF_NAMESPACE_ID::int32 relayid_;
  int contractinpacket_;
  friend struct ::TableStruct_contract_5fin_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ContractIn_Load

// optional string waitTimePacketQueue = 1;
inline bool ContractIn_Load::_internal_has_waittimepacketqueue() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ContractIn_Load::has_waittimepacketqueue() const {
  return _internal_has_waittimepacketqueue();
}
inline void ContractIn_Load::clear_waittimepacketqueue() {
  waittimepacketqueue_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ContractIn_Load::waittimepacketqueue() const {
  // @@protoc_insertion_point(field_get:contract_in.ContractIn.Load.waitTimePacketQueue)
  return _internal_waittimepacketqueue();
}
inline void ContractIn_Load::set_waittimepacketqueue(const std::string& value) {
  _internal_set_waittimepacketqueue(value);
  // @@protoc_insertion_point(field_set:contract_in.ContractIn.Load.waitTimePacketQueue)
}
inline std::string* ContractIn_Load::mutable_waittimepacketqueue() {
  // @@protoc_insertion_point(field_mutable:contract_in.ContractIn.Load.waitTimePacketQueue)
  return _internal_mutable_waittimepacketqueue();
}
inline const std::string& ContractIn_Load::_internal_waittimepacketqueue() const {
  return waittimepacketqueue_.GetNoArena();
}
inline void ContractIn_Load::_internal_set_waittimepacketqueue(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  waittimepacketqueue_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ContractIn_Load::set_waittimepacketqueue(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  waittimepacketqueue_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:contract_in.ContractIn.Load.waitTimePacketQueue)
}
inline void ContractIn_Load::set_waittimepacketqueue(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  waittimepacketqueue_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:contract_in.ContractIn.Load.waitTimePacketQueue)
}
inline void ContractIn_Load::set_waittimepacketqueue(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  waittimepacketqueue_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:contract_in.ContractIn.Load.waitTimePacketQueue)
}
inline std::string* ContractIn_Load::_internal_mutable_waittimepacketqueue() {
  _has_bits_[0] |= 0x00000001u;
  return waittimepacketqueue_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ContractIn_Load::release_waittimepacketqueue() {
  // @@protoc_insertion_point(field_release:contract_in.ContractIn.Load.waitTimePacketQueue)
  if (!has_waittimepacketqueue()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return waittimepacketqueue_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ContractIn_Load::set_allocated_waittimepacketqueue(std::string* waittimepacketqueue) {
  if (waittimepacketqueue != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  waittimepacketqueue_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), waittimepacketqueue);
  // @@protoc_insertion_point(field_set_allocated:contract_in.ContractIn.Load.waitTimePacketQueue)
}

// optional int32 userNumber = 2;
inline bool ContractIn_Load::_internal_has_usernumber() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ContractIn_Load::has_usernumber() const {
  return _internal_has_usernumber();
}
inline void ContractIn_Load::clear_usernumber() {
  usernumber_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ContractIn_Load::_internal_usernumber() const {
  return usernumber_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ContractIn_Load::usernumber() const {
  // @@protoc_insertion_point(field_get:contract_in.ContractIn.Load.userNumber)
  return _internal_usernumber();
}
inline void ContractIn_Load::_internal_set_usernumber(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  usernumber_ = value;
}
inline void ContractIn_Load::set_usernumber(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_usernumber(value);
  // @@protoc_insertion_point(field_set:contract_in.ContractIn.Load.userNumber)
}

// optional int32 dropNumber = 3;
inline bool ContractIn_Load::_internal_has_dropnumber() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ContractIn_Load::has_dropnumber() const {
  return _internal_has_dropnumber();
}
inline void ContractIn_Load::clear_dropnumber() {
  dropnumber_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ContractIn_Load::_internal_dropnumber() const {
  return dropnumber_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ContractIn_Load::dropnumber() const {
  // @@protoc_insertion_point(field_get:contract_in.ContractIn.Load.dropNumber)
  return _internal_dropnumber();
}
inline void ContractIn_Load::_internal_set_dropnumber(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  dropnumber_ = value;
}
inline void ContractIn_Load::set_dropnumber(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_dropnumber(value);
  // @@protoc_insertion_point(field_set:contract_in.ContractIn.Load.dropNumber)
}

// -------------------------------------------------------------------

// ContractIn_Location

// optional string x = 1;
inline bool ContractIn_Location::_internal_has_x() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ContractIn_Location::has_x() const {
  return _internal_has_x();
}
inline void ContractIn_Location::clear_x() {
  x_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ContractIn_Location::x() const {
  // @@protoc_insertion_point(field_get:contract_in.ContractIn.Location.x)
  return _internal_x();
}
inline void ContractIn_Location::set_x(const std::string& value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:contract_in.ContractIn.Location.x)
}
inline std::string* ContractIn_Location::mutable_x() {
  // @@protoc_insertion_point(field_mutable:contract_in.ContractIn.Location.x)
  return _internal_mutable_x();
}
inline const std::string& ContractIn_Location::_internal_x() const {
  return x_.GetNoArena();
}
inline void ContractIn_Location::_internal_set_x(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  x_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ContractIn_Location::set_x(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  x_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:contract_in.ContractIn.Location.x)
}
inline void ContractIn_Location::set_x(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  x_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:contract_in.ContractIn.Location.x)
}
inline void ContractIn_Location::set_x(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  x_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:contract_in.ContractIn.Location.x)
}
inline std::string* ContractIn_Location::_internal_mutable_x() {
  _has_bits_[0] |= 0x00000001u;
  return x_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ContractIn_Location::release_x() {
  // @@protoc_insertion_point(field_release:contract_in.ContractIn.Location.x)
  if (!has_x()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return x_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ContractIn_Location::set_allocated_x(std::string* x) {
  if (x != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  x_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), x);
  // @@protoc_insertion_point(field_set_allocated:contract_in.ContractIn.Location.x)
}

// optional string y = 2;
inline bool ContractIn_Location::_internal_has_y() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ContractIn_Location::has_y() const {
  return _internal_has_y();
}
inline void ContractIn_Location::clear_y() {
  y_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ContractIn_Location::y() const {
  // @@protoc_insertion_point(field_get:contract_in.ContractIn.Location.y)
  return _internal_y();
}
inline void ContractIn_Location::set_y(const std::string& value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:contract_in.ContractIn.Location.y)
}
inline std::string* ContractIn_Location::mutable_y() {
  // @@protoc_insertion_point(field_mutable:contract_in.ContractIn.Location.y)
  return _internal_mutable_y();
}
inline const std::string& ContractIn_Location::_internal_y() const {
  return y_.GetNoArena();
}
inline void ContractIn_Location::_internal_set_y(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  y_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ContractIn_Location::set_y(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  y_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:contract_in.ContractIn.Location.y)
}
inline void ContractIn_Location::set_y(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  y_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:contract_in.ContractIn.Location.y)
}
inline void ContractIn_Location::set_y(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  y_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:contract_in.ContractIn.Location.y)
}
inline std::string* ContractIn_Location::_internal_mutable_y() {
  _has_bits_[0] |= 0x00000002u;
  return y_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ContractIn_Location::release_y() {
  // @@protoc_insertion_point(field_release:contract_in.ContractIn.Location.y)
  if (!has_y()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return y_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ContractIn_Location::set_allocated_y(std::string* y) {
  if (y != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  y_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), y);
  // @@protoc_insertion_point(field_set_allocated:contract_in.ContractIn.Location.y)
}

// -------------------------------------------------------------------

// ContractIn_Status

// optional .contract_in.ContractIn.Location location = 1;
inline bool ContractIn_Status::_internal_has_location() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || location_ != nullptr);
  return value;
}
inline bool ContractIn_Status::has_location() const {
  return _internal_has_location();
}
inline void ContractIn_Status::clear_location() {
  if (location_ != nullptr) location_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::contract_in::ContractIn_Location& ContractIn_Status::_internal_location() const {
  const ::contract_in::ContractIn_Location* p = location_;
  return p != nullptr ? *p : *reinterpret_cast<const ::contract_in::ContractIn_Location*>(
      &::contract_in::_ContractIn_Location_default_instance_);
}
inline const ::contract_in::ContractIn_Location& ContractIn_Status::location() const {
  // @@protoc_insertion_point(field_get:contract_in.ContractIn.Status.location)
  return _internal_location();
}
inline ::contract_in::ContractIn_Location* ContractIn_Status::release_location() {
  // @@protoc_insertion_point(field_release:contract_in.ContractIn.Status.location)
  _has_bits_[0] &= ~0x00000001u;
  ::contract_in::ContractIn_Location* temp = location_;
  location_ = nullptr;
  return temp;
}
inline ::contract_in::ContractIn_Location* ContractIn_Status::_internal_mutable_location() {
  _has_bits_[0] |= 0x00000001u;
  if (location_ == nullptr) {
    auto* p = CreateMaybeMessage<::contract_in::ContractIn_Location>(GetArenaNoVirtual());
    location_ = p;
  }
  return location_;
}
inline ::contract_in::ContractIn_Location* ContractIn_Status::mutable_location() {
  // @@protoc_insertion_point(field_mutable:contract_in.ContractIn.Status.location)
  return _internal_mutable_location();
}
inline void ContractIn_Status::set_allocated_location(::contract_in::ContractIn_Location* location) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete location_;
  }
  if (location) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      location = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  location_ = location;
  // @@protoc_insertion_point(field_set_allocated:contract_in.ContractIn.Status.location)
}

// -------------------------------------------------------------------

// ContractIn_NotifyStatusController

// optional .contract_in.ContractIn.Status status = 1;
inline bool ContractIn_NotifyStatusController::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || status_ != nullptr);
  return value;
}
inline bool ContractIn_NotifyStatusController::has_status() const {
  return _internal_has_status();
}
inline void ContractIn_NotifyStatusController::clear_status() {
  if (status_ != nullptr) status_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::contract_in::ContractIn_Status& ContractIn_NotifyStatusController::_internal_status() const {
  const ::contract_in::ContractIn_Status* p = status_;
  return p != nullptr ? *p : *reinterpret_cast<const ::contract_in::ContractIn_Status*>(
      &::contract_in::_ContractIn_Status_default_instance_);
}
inline const ::contract_in::ContractIn_Status& ContractIn_NotifyStatusController::status() const {
  // @@protoc_insertion_point(field_get:contract_in.ContractIn.NotifyStatusController.status)
  return _internal_status();
}
inline ::contract_in::ContractIn_Status* ContractIn_NotifyStatusController::release_status() {
  // @@protoc_insertion_point(field_release:contract_in.ContractIn.NotifyStatusController.status)
  _has_bits_[0] &= ~0x00000001u;
  ::contract_in::ContractIn_Status* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::contract_in::ContractIn_Status* ContractIn_NotifyStatusController::_internal_mutable_status() {
  _has_bits_[0] |= 0x00000001u;
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::contract_in::ContractIn_Status>(GetArenaNoVirtual());
    status_ = p;
  }
  return status_;
}
inline ::contract_in::ContractIn_Status* ContractIn_NotifyStatusController::mutable_status() {
  // @@protoc_insertion_point(field_mutable:contract_in.ContractIn.NotifyStatusController.status)
  return _internal_mutable_status();
}
inline void ContractIn_NotifyStatusController::set_allocated_status(::contract_in::ContractIn_Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:contract_in.ContractIn.NotifyStatusController.status)
}

// -------------------------------------------------------------------

// ContractIn_NotifyStatusUser

// optional .contract_in.ContractIn.Status status = 1;
inline bool ContractIn_NotifyStatusUser::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || status_ != nullptr);
  return value;
}
inline bool ContractIn_NotifyStatusUser::has_status() const {
  return _internal_has_status();
}
inline void ContractIn_NotifyStatusUser::clear_status() {
  if (status_ != nullptr) status_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::contract_in::ContractIn_Status& ContractIn_NotifyStatusUser::_internal_status() const {
  const ::contract_in::ContractIn_Status* p = status_;
  return p != nullptr ? *p : *reinterpret_cast<const ::contract_in::ContractIn_Status*>(
      &::contract_in::_ContractIn_Status_default_instance_);
}
inline const ::contract_in::ContractIn_Status& ContractIn_NotifyStatusUser::status() const {
  // @@protoc_insertion_point(field_get:contract_in.ContractIn.NotifyStatusUser.status)
  return _internal_status();
}
inline ::contract_in::ContractIn_Status* ContractIn_NotifyStatusUser::release_status() {
  // @@protoc_insertion_point(field_release:contract_in.ContractIn.NotifyStatusUser.status)
  _has_bits_[0] &= ~0x00000001u;
  ::contract_in::ContractIn_Status* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::contract_in::ContractIn_Status* ContractIn_NotifyStatusUser::_internal_mutable_status() {
  _has_bits_[0] |= 0x00000001u;
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::contract_in::ContractIn_Status>(GetArenaNoVirtual());
    status_ = p;
  }
  return status_;
}
inline ::contract_in::ContractIn_Status* ContractIn_NotifyStatusUser::mutable_status() {
  // @@protoc_insertion_point(field_mutable:contract_in.ContractIn.NotifyStatusUser.status)
  return _internal_mutable_status();
}
inline void ContractIn_NotifyStatusUser::set_allocated_status(::contract_in::ContractIn_Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:contract_in.ContractIn.NotifyStatusUser.status)
}

// -------------------------------------------------------------------

// ContractIn_NotifyStatusRelay

// optional .contract_in.ContractIn.Status status = 1;
inline bool ContractIn_NotifyStatusRelay::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || status_ != nullptr);
  return value;
}
inline bool ContractIn_NotifyStatusRelay::has_status() const {
  return _internal_has_status();
}
inline void ContractIn_NotifyStatusRelay::clear_status() {
  if (status_ != nullptr) status_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::contract_in::ContractIn_Status& ContractIn_NotifyStatusRelay::_internal_status() const {
  const ::contract_in::ContractIn_Status* p = status_;
  return p != nullptr ? *p : *reinterpret_cast<const ::contract_in::ContractIn_Status*>(
      &::contract_in::_ContractIn_Status_default_instance_);
}
inline const ::contract_in::ContractIn_Status& ContractIn_NotifyStatusRelay::status() const {
  // @@protoc_insertion_point(field_get:contract_in.ContractIn.NotifyStatusRelay.status)
  return _internal_status();
}
inline ::contract_in::ContractIn_Status* ContractIn_NotifyStatusRelay::release_status() {
  // @@protoc_insertion_point(field_release:contract_in.ContractIn.NotifyStatusRelay.status)
  _has_bits_[0] &= ~0x00000001u;
  ::contract_in::ContractIn_Status* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::contract_in::ContractIn_Status* ContractIn_NotifyStatusRelay::_internal_mutable_status() {
  _has_bits_[0] |= 0x00000001u;
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::contract_in::ContractIn_Status>(GetArenaNoVirtual());
    status_ = p;
  }
  return status_;
}
inline ::contract_in::ContractIn_Status* ContractIn_NotifyStatusRelay::mutable_status() {
  // @@protoc_insertion_point(field_mutable:contract_in.ContractIn.NotifyStatusRelay.status)
  return _internal_mutable_status();
}
inline void ContractIn_NotifyStatusRelay::set_allocated_status(::contract_in::ContractIn_Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:contract_in.ContractIn.NotifyStatusRelay.status)
}

// -------------------------------------------------------------------

// ContractIn_Unregister

// optional .contract_in.ContractIn.Event event = 1;
inline bool ContractIn_Unregister::_internal_has_event() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ContractIn_Unregister::has_event() const {
  return _internal_has_event();
}
inline void ContractIn_Unregister::clear_event() {
  event_ = 1;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::contract_in::ContractIn_Event ContractIn_Unregister::_internal_event() const {
  return static_cast< ::contract_in::ContractIn_Event >(event_);
}
inline ::contract_in::ContractIn_Event ContractIn_Unregister::event() const {
  // @@protoc_insertion_point(field_get:contract_in.ContractIn.Unregister.event)
  return _internal_event();
}
inline void ContractIn_Unregister::_internal_set_event(::contract_in::ContractIn_Event value) {
  assert(::contract_in::ContractIn_Event_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  event_ = value;
}
inline void ContractIn_Unregister::set_event(::contract_in::ContractIn_Event value) {
  _internal_set_event(value);
  // @@protoc_insertion_point(field_set:contract_in.ContractIn.Unregister.event)
}

// -------------------------------------------------------------------

// ContractIn_Register

// optional .contract_in.ContractIn.Status status = 1;
inline bool ContractIn_Register::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || status_ != nullptr);
  return value;
}
inline bool ContractIn_Register::has_status() const {
  return _internal_has_status();
}
inline void ContractIn_Register::clear_status() {
  if (status_ != nullptr) status_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::contract_in::ContractIn_Status& ContractIn_Register::_internal_status() const {
  const ::contract_in::ContractIn_Status* p = status_;
  return p != nullptr ? *p : *reinterpret_cast<const ::contract_in::ContractIn_Status*>(
      &::contract_in::_ContractIn_Status_default_instance_);
}
inline const ::contract_in::ContractIn_Status& ContractIn_Register::status() const {
  // @@protoc_insertion_point(field_get:contract_in.ContractIn.Register.status)
  return _internal_status();
}
inline ::contract_in::ContractIn_Status* ContractIn_Register::release_status() {
  // @@protoc_insertion_point(field_release:contract_in.ContractIn.Register.status)
  _has_bits_[0] &= ~0x00000001u;
  ::contract_in::ContractIn_Status* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::contract_in::ContractIn_Status* ContractIn_Register::_internal_mutable_status() {
  _has_bits_[0] |= 0x00000001u;
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::contract_in::ContractIn_Status>(GetArenaNoVirtual());
    status_ = p;
  }
  return status_;
}
inline ::contract_in::ContractIn_Status* ContractIn_Register::mutable_status() {
  // @@protoc_insertion_point(field_mutable:contract_in.ContractIn.Register.status)
  return _internal_mutable_status();
}
inline void ContractIn_Register::set_allocated_status(::contract_in::ContractIn_Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:contract_in.ContractIn.Register.status)
}

// optional .contract_in.ContractIn.Load load = 2;
inline bool ContractIn_Register::_internal_has_load() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || load_ != nullptr);
  return value;
}
inline bool ContractIn_Register::has_load() const {
  return _internal_has_load();
}
inline void ContractIn_Register::clear_load() {
  if (load_ != nullptr) load_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::contract_in::ContractIn_Load& ContractIn_Register::_internal_load() const {
  const ::contract_in::ContractIn_Load* p = load_;
  return p != nullptr ? *p : *reinterpret_cast<const ::contract_in::ContractIn_Load*>(
      &::contract_in::_ContractIn_Load_default_instance_);
}
inline const ::contract_in::ContractIn_Load& ContractIn_Register::load() const {
  // @@protoc_insertion_point(field_get:contract_in.ContractIn.Register.load)
  return _internal_load();
}
inline ::contract_in::ContractIn_Load* ContractIn_Register::release_load() {
  // @@protoc_insertion_point(field_release:contract_in.ContractIn.Register.load)
  _has_bits_[0] &= ~0x00000002u;
  ::contract_in::ContractIn_Load* temp = load_;
  load_ = nullptr;
  return temp;
}
inline ::contract_in::ContractIn_Load* ContractIn_Register::_internal_mutable_load() {
  _has_bits_[0] |= 0x00000002u;
  if (load_ == nullptr) {
    auto* p = CreateMaybeMessage<::contract_in::ContractIn_Load>(GetArenaNoVirtual());
    load_ = p;
  }
  return load_;
}
inline ::contract_in::ContractIn_Load* ContractIn_Register::mutable_load() {
  // @@protoc_insertion_point(field_mutable:contract_in.ContractIn.Register.load)
  return _internal_mutable_load();
}
inline void ContractIn_Register::set_allocated_load(::contract_in::ContractIn_Load* load) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete load_;
  }
  if (load) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      load = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, load, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  load_ = load;
  // @@protoc_insertion_point(field_set_allocated:contract_in.ContractIn.Register.load)
}

// -------------------------------------------------------------------

// ContractIn_TelemetryByHop

// optional int32 relayId = 1;
inline bool ContractIn_TelemetryByHop::_internal_has_relayid() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ContractIn_TelemetryByHop::has_relayid() const {
  return _internal_has_relayid();
}
inline void ContractIn_TelemetryByHop::clear_relayid() {
  relayid_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ContractIn_TelemetryByHop::_internal_relayid() const {
  return relayid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ContractIn_TelemetryByHop::relayid() const {
  // @@protoc_insertion_point(field_get:contract_in.ContractIn.TelemetryByHop.relayId)
  return _internal_relayid();
}
inline void ContractIn_TelemetryByHop::_internal_set_relayid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  relayid_ = value;
}
inline void ContractIn_TelemetryByHop::set_relayid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_relayid(value);
  // @@protoc_insertion_point(field_set:contract_in.ContractIn.TelemetryByHop.relayId)
}

// optional string timeReceived = 2;
inline bool ContractIn_TelemetryByHop::_internal_has_timereceived() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ContractIn_TelemetryByHop::has_timereceived() const {
  return _internal_has_timereceived();
}
inline void ContractIn_TelemetryByHop::clear_timereceived() {
  timereceived_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ContractIn_TelemetryByHop::timereceived() const {
  // @@protoc_insertion_point(field_get:contract_in.ContractIn.TelemetryByHop.timeReceived)
  return _internal_timereceived();
}
inline void ContractIn_TelemetryByHop::set_timereceived(const std::string& value) {
  _internal_set_timereceived(value);
  // @@protoc_insertion_point(field_set:contract_in.ContractIn.TelemetryByHop.timeReceived)
}
inline std::string* ContractIn_TelemetryByHop::mutable_timereceived() {
  // @@protoc_insertion_point(field_mutable:contract_in.ContractIn.TelemetryByHop.timeReceived)
  return _internal_mutable_timereceived();
}
inline const std::string& ContractIn_TelemetryByHop::_internal_timereceived() const {
  return timereceived_.GetNoArena();
}
inline void ContractIn_TelemetryByHop::_internal_set_timereceived(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  timereceived_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ContractIn_TelemetryByHop::set_timereceived(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  timereceived_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:contract_in.ContractIn.TelemetryByHop.timeReceived)
}
inline void ContractIn_TelemetryByHop::set_timereceived(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  timereceived_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:contract_in.ContractIn.TelemetryByHop.timeReceived)
}
inline void ContractIn_TelemetryByHop::set_timereceived(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  timereceived_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:contract_in.ContractIn.TelemetryByHop.timeReceived)
}
inline std::string* ContractIn_TelemetryByHop::_internal_mutable_timereceived() {
  _has_bits_[0] |= 0x00000001u;
  return timereceived_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ContractIn_TelemetryByHop::release_timereceived() {
  // @@protoc_insertion_point(field_release:contract_in.ContractIn.TelemetryByHop.timeReceived)
  if (!has_timereceived()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return timereceived_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ContractIn_TelemetryByHop::set_allocated_timereceived(std::string* timereceived) {
  if (timereceived != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  timereceived_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), timereceived);
  // @@protoc_insertion_point(field_set_allocated:contract_in.ContractIn.TelemetryByHop.timeReceived)
}

// optional int32 lenQueueMac = 3;
inline bool ContractIn_TelemetryByHop::_internal_has_lenqueuemac() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ContractIn_TelemetryByHop::has_lenqueuemac() const {
  return _internal_has_lenqueuemac();
}
inline void ContractIn_TelemetryByHop::clear_lenqueuemac() {
  lenqueuemac_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ContractIn_TelemetryByHop::_internal_lenqueuemac() const {
  return lenqueuemac_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ContractIn_TelemetryByHop::lenqueuemac() const {
  // @@protoc_insertion_point(field_get:contract_in.ContractIn.TelemetryByHop.lenQueueMac)
  return _internal_lenqueuemac();
}
inline void ContractIn_TelemetryByHop::_internal_set_lenqueuemac(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  lenqueuemac_ = value;
}
inline void ContractIn_TelemetryByHop::set_lenqueuemac(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_lenqueuemac(value);
  // @@protoc_insertion_point(field_set:contract_in.ContractIn.TelemetryByHop.lenQueueMac)
}

// optional int32 lenQueueNet = 4;
inline bool ContractIn_TelemetryByHop::_internal_has_lenqueuenet() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ContractIn_TelemetryByHop::has_lenqueuenet() const {
  return _internal_has_lenqueuenet();
}
inline void ContractIn_TelemetryByHop::clear_lenqueuenet() {
  lenqueuenet_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ContractIn_TelemetryByHop::_internal_lenqueuenet() const {
  return lenqueuenet_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ContractIn_TelemetryByHop::lenqueuenet() const {
  // @@protoc_insertion_point(field_get:contract_in.ContractIn.TelemetryByHop.lenQueueNet)
  return _internal_lenqueuenet();
}
inline void ContractIn_TelemetryByHop::_internal_set_lenqueuenet(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  lenqueuenet_ = value;
}
inline void ContractIn_TelemetryByHop::set_lenqueuenet(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_lenqueuenet(value);
  // @@protoc_insertion_point(field_set:contract_in.ContractIn.TelemetryByHop.lenQueueNet)
}

// optional int32 packetDropMac = 5;
inline bool ContractIn_TelemetryByHop::_internal_has_packetdropmac() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ContractIn_TelemetryByHop::has_packetdropmac() const {
  return _internal_has_packetdropmac();
}
inline void ContractIn_TelemetryByHop::clear_packetdropmac() {
  packetdropmac_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ContractIn_TelemetryByHop::_internal_packetdropmac() const {
  return packetdropmac_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ContractIn_TelemetryByHop::packetdropmac() const {
  // @@protoc_insertion_point(field_get:contract_in.ContractIn.TelemetryByHop.packetDropMac)
  return _internal_packetdropmac();
}
inline void ContractIn_TelemetryByHop::_internal_set_packetdropmac(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000020u;
  packetdropmac_ = value;
}
inline void ContractIn_TelemetryByHop::set_packetdropmac(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_packetdropmac(value);
  // @@protoc_insertion_point(field_set:contract_in.ContractIn.TelemetryByHop.packetDropMac)
}

// optional int32 packetDropNet = 6;
inline bool ContractIn_TelemetryByHop::_internal_has_packetdropnet() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ContractIn_TelemetryByHop::has_packetdropnet() const {
  return _internal_has_packetdropnet();
}
inline void ContractIn_TelemetryByHop::clear_packetdropnet() {
  packetdropnet_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ContractIn_TelemetryByHop::_internal_packetdropnet() const {
  return packetdropnet_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ContractIn_TelemetryByHop::packetdropnet() const {
  // @@protoc_insertion_point(field_get:contract_in.ContractIn.TelemetryByHop.packetDropNet)
  return _internal_packetdropnet();
}
inline void ContractIn_TelemetryByHop::_internal_set_packetdropnet(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000040u;
  packetdropnet_ = value;
}
inline void ContractIn_TelemetryByHop::set_packetdropnet(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_packetdropnet(value);
  // @@protoc_insertion_point(field_set:contract_in.ContractIn.TelemetryByHop.packetDropNet)
}

// optional string rssi = 7;
inline bool ContractIn_TelemetryByHop::_internal_has_rssi() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ContractIn_TelemetryByHop::has_rssi() const {
  return _internal_has_rssi();
}
inline void ContractIn_TelemetryByHop::clear_rssi() {
  rssi_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ContractIn_TelemetryByHop::rssi() const {
  // @@protoc_insertion_point(field_get:contract_in.ContractIn.TelemetryByHop.rssi)
  return _internal_rssi();
}
inline void ContractIn_TelemetryByHop::set_rssi(const std::string& value) {
  _internal_set_rssi(value);
  // @@protoc_insertion_point(field_set:contract_in.ContractIn.TelemetryByHop.rssi)
}
inline std::string* ContractIn_TelemetryByHop::mutable_rssi() {
  // @@protoc_insertion_point(field_mutable:contract_in.ContractIn.TelemetryByHop.rssi)
  return _internal_mutable_rssi();
}
inline const std::string& ContractIn_TelemetryByHop::_internal_rssi() const {
  return rssi_.GetNoArena();
}
inline void ContractIn_TelemetryByHop::_internal_set_rssi(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  rssi_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ContractIn_TelemetryByHop::set_rssi(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  rssi_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:contract_in.ContractIn.TelemetryByHop.rssi)
}
inline void ContractIn_TelemetryByHop::set_rssi(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  rssi_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:contract_in.ContractIn.TelemetryByHop.rssi)
}
inline void ContractIn_TelemetryByHop::set_rssi(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  rssi_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:contract_in.ContractIn.TelemetryByHop.rssi)
}
inline std::string* ContractIn_TelemetryByHop::_internal_mutable_rssi() {
  _has_bits_[0] |= 0x00000002u;
  return rssi_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ContractIn_TelemetryByHop::release_rssi() {
  // @@protoc_insertion_point(field_release:contract_in.ContractIn.TelemetryByHop.rssi)
  if (!has_rssi()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return rssi_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ContractIn_TelemetryByHop::set_allocated_rssi(std::string* rssi) {
  if (rssi != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  rssi_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), rssi);
  // @@protoc_insertion_point(field_set_allocated:contract_in.ContractIn.TelemetryByHop.rssi)
}

// -------------------------------------------------------------------

// ContractIn_Telemetry

// optional int32 source = 1;
inline bool ContractIn_Telemetry::_internal_has_source() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ContractIn_Telemetry::has_source() const {
  return _internal_has_source();
}
inline void ContractIn_Telemetry::clear_source() {
  source_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ContractIn_Telemetry::_internal_source() const {
  return source_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ContractIn_Telemetry::source() const {
  // @@protoc_insertion_point(field_get:contract_in.ContractIn.Telemetry.source)
  return _internal_source();
}
inline void ContractIn_Telemetry::_internal_set_source(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  source_ = value;
}
inline void ContractIn_Telemetry::set_source(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_source(value);
  // @@protoc_insertion_point(field_set:contract_in.ContractIn.Telemetry.source)
}

// optional int32 destination = 2;
inline bool ContractIn_Telemetry::_internal_has_destination() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ContractIn_Telemetry::has_destination() const {
  return _internal_has_destination();
}
inline void ContractIn_Telemetry::clear_destination() {
  destination_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ContractIn_Telemetry::_internal_destination() const {
  return destination_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ContractIn_Telemetry::destination() const {
  // @@protoc_insertion_point(field_get:contract_in.ContractIn.Telemetry.destination)
  return _internal_destination();
}
inline void ContractIn_Telemetry::_internal_set_destination(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  destination_ = value;
}
inline void ContractIn_Telemetry::set_destination(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_destination(value);
  // @@protoc_insertion_point(field_set:contract_in.ContractIn.Telemetry.destination)
}

// optional int32 messageType = 3;
inline bool ContractIn_Telemetry::_internal_has_messagetype() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ContractIn_Telemetry::has_messagetype() const {
  return _internal_has_messagetype();
}
inline void ContractIn_Telemetry::clear_messagetype() {
  messagetype_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ContractIn_Telemetry::_internal_messagetype() const {
  return messagetype_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ContractIn_Telemetry::messagetype() const {
  // @@protoc_insertion_point(field_get:contract_in.ContractIn.Telemetry.messageType)
  return _internal_messagetype();
}
inline void ContractIn_Telemetry::_internal_set_messagetype(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  messagetype_ = value;
}
inline void ContractIn_Telemetry::set_messagetype(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_messagetype(value);
  // @@protoc_insertion_point(field_set:contract_in.ContractIn.Telemetry.messageType)
}

// optional int32 size = 4;
inline bool ContractIn_Telemetry::_internal_has_size() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ContractIn_Telemetry::has_size() const {
  return _internal_has_size();
}
inline void ContractIn_Telemetry::clear_size() {
  size_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ContractIn_Telemetry::_internal_size() const {
  return size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ContractIn_Telemetry::size() const {
  // @@protoc_insertion_point(field_get:contract_in.ContractIn.Telemetry.size)
  return _internal_size();
}
inline void ContractIn_Telemetry::_internal_set_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  size_ = value;
}
inline void ContractIn_Telemetry::set_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:contract_in.ContractIn.Telemetry.size)
}

// optional int32 idVideo = 5;
inline bool ContractIn_Telemetry::_internal_has_idvideo() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ContractIn_Telemetry::has_idvideo() const {
  return _internal_has_idvideo();
}
inline void ContractIn_Telemetry::clear_idvideo() {
  idvideo_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ContractIn_Telemetry::_internal_idvideo() const {
  return idvideo_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ContractIn_Telemetry::idvideo() const {
  // @@protoc_insertion_point(field_get:contract_in.ContractIn.Telemetry.idVideo)
  return _internal_idvideo();
}
inline void ContractIn_Telemetry::_internal_set_idvideo(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  idvideo_ = value;
}
inline void ContractIn_Telemetry::set_idvideo(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_idvideo(value);
  // @@protoc_insertion_point(field_set:contract_in.ContractIn.Telemetry.idVideo)
}

// repeated .contract_in.ContractIn.TelemetryByHop msgTelemetryByHop = 6;
inline int ContractIn_Telemetry::_internal_msgtelemetrybyhop_size() const {
  return msgtelemetrybyhop_.size();
}
inline int ContractIn_Telemetry::msgtelemetrybyhop_size() const {
  return _internal_msgtelemetrybyhop_size();
}
inline void ContractIn_Telemetry::clear_msgtelemetrybyhop() {
  msgtelemetrybyhop_.Clear();
}
inline ::contract_in::ContractIn_TelemetryByHop* ContractIn_Telemetry::mutable_msgtelemetrybyhop(int index) {
  // @@protoc_insertion_point(field_mutable:contract_in.ContractIn.Telemetry.msgTelemetryByHop)
  return msgtelemetrybyhop_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::contract_in::ContractIn_TelemetryByHop >*
ContractIn_Telemetry::mutable_msgtelemetrybyhop() {
  // @@protoc_insertion_point(field_mutable_list:contract_in.ContractIn.Telemetry.msgTelemetryByHop)
  return &msgtelemetrybyhop_;
}
inline const ::contract_in::ContractIn_TelemetryByHop& ContractIn_Telemetry::_internal_msgtelemetrybyhop(int index) const {
  return msgtelemetrybyhop_.Get(index);
}
inline const ::contract_in::ContractIn_TelemetryByHop& ContractIn_Telemetry::msgtelemetrybyhop(int index) const {
  // @@protoc_insertion_point(field_get:contract_in.ContractIn.Telemetry.msgTelemetryByHop)
  return _internal_msgtelemetrybyhop(index);
}
inline ::contract_in::ContractIn_TelemetryByHop* ContractIn_Telemetry::_internal_add_msgtelemetrybyhop() {
  return msgtelemetrybyhop_.Add();
}
inline ::contract_in::ContractIn_TelemetryByHop* ContractIn_Telemetry::add_msgtelemetrybyhop() {
  // @@protoc_insertion_point(field_add:contract_in.ContractIn.Telemetry.msgTelemetryByHop)
  return _internal_add_msgtelemetrybyhop();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::contract_in::ContractIn_TelemetryByHop >&
ContractIn_Telemetry::msgtelemetrybyhop() const {
  // @@protoc_insertion_point(field_list:contract_in.ContractIn.Telemetry.msgTelemetryByHop)
  return msgtelemetrybyhop_;
}

// -------------------------------------------------------------------

// ContractIn

// optional string time = 1;
inline bool ContractIn::_internal_has_time() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ContractIn::has_time() const {
  return _internal_has_time();
}
inline void ContractIn::clear_time() {
  time_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ContractIn::time() const {
  // @@protoc_insertion_point(field_get:contract_in.ContractIn.time)
  return _internal_time();
}
inline void ContractIn::set_time(const std::string& value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:contract_in.ContractIn.time)
}
inline std::string* ContractIn::mutable_time() {
  // @@protoc_insertion_point(field_mutable:contract_in.ContractIn.time)
  return _internal_mutable_time();
}
inline const std::string& ContractIn::_internal_time() const {
  return time_.GetNoArena();
}
inline void ContractIn::_internal_set_time(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  time_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ContractIn::set_time(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  time_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:contract_in.ContractIn.time)
}
inline void ContractIn::set_time(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  time_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:contract_in.ContractIn.time)
}
inline void ContractIn::set_time(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  time_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:contract_in.ContractIn.time)
}
inline std::string* ContractIn::_internal_mutable_time() {
  _has_bits_[0] |= 0x00000001u;
  return time_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ContractIn::release_time() {
  // @@protoc_insertion_point(field_release:contract_in.ContractIn.time)
  if (!has_time()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return time_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ContractIn::set_allocated_time(std::string* time) {
  if (time != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  time_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), time);
  // @@protoc_insertion_point(field_set_allocated:contract_in.ContractIn.time)
}

// optional int32 userId = 2;
inline bool ContractIn::_internal_has_userid() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ContractIn::has_userid() const {
  return _internal_has_userid();
}
inline void ContractIn::clear_userid() {
  userid_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ContractIn::_internal_userid() const {
  return userid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ContractIn::userid() const {
  // @@protoc_insertion_point(field_get:contract_in.ContractIn.userId)
  return _internal_userid();
}
inline void ContractIn::_internal_set_userid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000080u;
  userid_ = value;
}
inline void ContractIn::set_userid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_userid(value);
  // @@protoc_insertion_point(field_set:contract_in.ContractIn.userId)
}

// optional int32 relayId = 3;
inline bool ContractIn::_internal_has_relayid() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool ContractIn::has_relayid() const {
  return _internal_has_relayid();
}
inline void ContractIn::clear_relayid() {
  relayid_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ContractIn::_internal_relayid() const {
  return relayid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ContractIn::relayid() const {
  // @@protoc_insertion_point(field_get:contract_in.ContractIn.relayId)
  return _internal_relayid();
}
inline void ContractIn::_internal_set_relayid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000100u;
  relayid_ = value;
}
inline void ContractIn::set_relayid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_relayid(value);
  // @@protoc_insertion_point(field_set:contract_in.ContractIn.relayId)
}

// required .contract_in.ContractIn.ContractInPacket contractInPacket = 4;
inline bool ContractIn::_internal_has_contractinpacket() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool ContractIn::has_contractinpacket() const {
  return _internal_has_contractinpacket();
}
inline void ContractIn::clear_contractinpacket() {
  contractinpacket_ = 1;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::contract_in::ContractIn_ContractInPacket ContractIn::_internal_contractinpacket() const {
  return static_cast< ::contract_in::ContractIn_ContractInPacket >(contractinpacket_);
}
inline ::contract_in::ContractIn_ContractInPacket ContractIn::contractinpacket() const {
  // @@protoc_insertion_point(field_get:contract_in.ContractIn.contractInPacket)
  return _internal_contractinpacket();
}
inline void ContractIn::_internal_set_contractinpacket(::contract_in::ContractIn_ContractInPacket value) {
  assert(::contract_in::ContractIn_ContractInPacket_IsValid(value));
  _has_bits_[0] |= 0x00000200u;
  contractinpacket_ = value;
}
inline void ContractIn::set_contractinpacket(::contract_in::ContractIn_ContractInPacket value) {
  _internal_set_contractinpacket(value);
  // @@protoc_insertion_point(field_set:contract_in.ContractIn.contractInPacket)
}

// optional .contract_in.ContractIn.NotifyStatusController msgNotifyStatusController = 5;
inline bool ContractIn::_internal_has_msgnotifystatuscontroller() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || msgnotifystatuscontroller_ != nullptr);
  return value;
}
inline bool ContractIn::has_msgnotifystatuscontroller() const {
  return _internal_has_msgnotifystatuscontroller();
}
inline void ContractIn::clear_msgnotifystatuscontroller() {
  if (msgnotifystatuscontroller_ != nullptr) msgnotifystatuscontroller_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::contract_in::ContractIn_NotifyStatusController& ContractIn::_internal_msgnotifystatuscontroller() const {
  const ::contract_in::ContractIn_NotifyStatusController* p = msgnotifystatuscontroller_;
  return p != nullptr ? *p : *reinterpret_cast<const ::contract_in::ContractIn_NotifyStatusController*>(
      &::contract_in::_ContractIn_NotifyStatusController_default_instance_);
}
inline const ::contract_in::ContractIn_NotifyStatusController& ContractIn::msgnotifystatuscontroller() const {
  // @@protoc_insertion_point(field_get:contract_in.ContractIn.msgNotifyStatusController)
  return _internal_msgnotifystatuscontroller();
}
inline ::contract_in::ContractIn_NotifyStatusController* ContractIn::release_msgnotifystatuscontroller() {
  // @@protoc_insertion_point(field_release:contract_in.ContractIn.msgNotifyStatusController)
  _has_bits_[0] &= ~0x00000002u;
  ::contract_in::ContractIn_NotifyStatusController* temp = msgnotifystatuscontroller_;
  msgnotifystatuscontroller_ = nullptr;
  return temp;
}
inline ::contract_in::ContractIn_NotifyStatusController* ContractIn::_internal_mutable_msgnotifystatuscontroller() {
  _has_bits_[0] |= 0x00000002u;
  if (msgnotifystatuscontroller_ == nullptr) {
    auto* p = CreateMaybeMessage<::contract_in::ContractIn_NotifyStatusController>(GetArenaNoVirtual());
    msgnotifystatuscontroller_ = p;
  }
  return msgnotifystatuscontroller_;
}
inline ::contract_in::ContractIn_NotifyStatusController* ContractIn::mutable_msgnotifystatuscontroller() {
  // @@protoc_insertion_point(field_mutable:contract_in.ContractIn.msgNotifyStatusController)
  return _internal_mutable_msgnotifystatuscontroller();
}
inline void ContractIn::set_allocated_msgnotifystatuscontroller(::contract_in::ContractIn_NotifyStatusController* msgnotifystatuscontroller) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete msgnotifystatuscontroller_;
  }
  if (msgnotifystatuscontroller) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      msgnotifystatuscontroller = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, msgnotifystatuscontroller, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  msgnotifystatuscontroller_ = msgnotifystatuscontroller;
  // @@protoc_insertion_point(field_set_allocated:contract_in.ContractIn.msgNotifyStatusController)
}

// optional .contract_in.ContractIn.NotifyStatusUser msgNotifyStatusUser = 6;
inline bool ContractIn::_internal_has_msgnotifystatususer() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || msgnotifystatususer_ != nullptr);
  return value;
}
inline bool ContractIn::has_msgnotifystatususer() const {
  return _internal_has_msgnotifystatususer();
}
inline void ContractIn::clear_msgnotifystatususer() {
  if (msgnotifystatususer_ != nullptr) msgnotifystatususer_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::contract_in::ContractIn_NotifyStatusUser& ContractIn::_internal_msgnotifystatususer() const {
  const ::contract_in::ContractIn_NotifyStatusUser* p = msgnotifystatususer_;
  return p != nullptr ? *p : *reinterpret_cast<const ::contract_in::ContractIn_NotifyStatusUser*>(
      &::contract_in::_ContractIn_NotifyStatusUser_default_instance_);
}
inline const ::contract_in::ContractIn_NotifyStatusUser& ContractIn::msgnotifystatususer() const {
  // @@protoc_insertion_point(field_get:contract_in.ContractIn.msgNotifyStatusUser)
  return _internal_msgnotifystatususer();
}
inline ::contract_in::ContractIn_NotifyStatusUser* ContractIn::release_msgnotifystatususer() {
  // @@protoc_insertion_point(field_release:contract_in.ContractIn.msgNotifyStatusUser)
  _has_bits_[0] &= ~0x00000004u;
  ::contract_in::ContractIn_NotifyStatusUser* temp = msgnotifystatususer_;
  msgnotifystatususer_ = nullptr;
  return temp;
}
inline ::contract_in::ContractIn_NotifyStatusUser* ContractIn::_internal_mutable_msgnotifystatususer() {
  _has_bits_[0] |= 0x00000004u;
  if (msgnotifystatususer_ == nullptr) {
    auto* p = CreateMaybeMessage<::contract_in::ContractIn_NotifyStatusUser>(GetArenaNoVirtual());
    msgnotifystatususer_ = p;
  }
  return msgnotifystatususer_;
}
inline ::contract_in::ContractIn_NotifyStatusUser* ContractIn::mutable_msgnotifystatususer() {
  // @@protoc_insertion_point(field_mutable:contract_in.ContractIn.msgNotifyStatusUser)
  return _internal_mutable_msgnotifystatususer();
}
inline void ContractIn::set_allocated_msgnotifystatususer(::contract_in::ContractIn_NotifyStatusUser* msgnotifystatususer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete msgnotifystatususer_;
  }
  if (msgnotifystatususer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      msgnotifystatususer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, msgnotifystatususer, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  msgnotifystatususer_ = msgnotifystatususer;
  // @@protoc_insertion_point(field_set_allocated:contract_in.ContractIn.msgNotifyStatusUser)
}

// optional .contract_in.ContractIn.NotifyStatusRelay msgNotifyStatusRelay = 7;
inline bool ContractIn::_internal_has_msgnotifystatusrelay() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || msgnotifystatusrelay_ != nullptr);
  return value;
}
inline bool ContractIn::has_msgnotifystatusrelay() const {
  return _internal_has_msgnotifystatusrelay();
}
inline void ContractIn::clear_msgnotifystatusrelay() {
  if (msgnotifystatusrelay_ != nullptr) msgnotifystatusrelay_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::contract_in::ContractIn_NotifyStatusRelay& ContractIn::_internal_msgnotifystatusrelay() const {
  const ::contract_in::ContractIn_NotifyStatusRelay* p = msgnotifystatusrelay_;
  return p != nullptr ? *p : *reinterpret_cast<const ::contract_in::ContractIn_NotifyStatusRelay*>(
      &::contract_in::_ContractIn_NotifyStatusRelay_default_instance_);
}
inline const ::contract_in::ContractIn_NotifyStatusRelay& ContractIn::msgnotifystatusrelay() const {
  // @@protoc_insertion_point(field_get:contract_in.ContractIn.msgNotifyStatusRelay)
  return _internal_msgnotifystatusrelay();
}
inline ::contract_in::ContractIn_NotifyStatusRelay* ContractIn::release_msgnotifystatusrelay() {
  // @@protoc_insertion_point(field_release:contract_in.ContractIn.msgNotifyStatusRelay)
  _has_bits_[0] &= ~0x00000008u;
  ::contract_in::ContractIn_NotifyStatusRelay* temp = msgnotifystatusrelay_;
  msgnotifystatusrelay_ = nullptr;
  return temp;
}
inline ::contract_in::ContractIn_NotifyStatusRelay* ContractIn::_internal_mutable_msgnotifystatusrelay() {
  _has_bits_[0] |= 0x00000008u;
  if (msgnotifystatusrelay_ == nullptr) {
    auto* p = CreateMaybeMessage<::contract_in::ContractIn_NotifyStatusRelay>(GetArenaNoVirtual());
    msgnotifystatusrelay_ = p;
  }
  return msgnotifystatusrelay_;
}
inline ::contract_in::ContractIn_NotifyStatusRelay* ContractIn::mutable_msgnotifystatusrelay() {
  // @@protoc_insertion_point(field_mutable:contract_in.ContractIn.msgNotifyStatusRelay)
  return _internal_mutable_msgnotifystatusrelay();
}
inline void ContractIn::set_allocated_msgnotifystatusrelay(::contract_in::ContractIn_NotifyStatusRelay* msgnotifystatusrelay) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete msgnotifystatusrelay_;
  }
  if (msgnotifystatusrelay) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      msgnotifystatusrelay = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, msgnotifystatusrelay, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  msgnotifystatusrelay_ = msgnotifystatusrelay;
  // @@protoc_insertion_point(field_set_allocated:contract_in.ContractIn.msgNotifyStatusRelay)
}

// optional .contract_in.ContractIn.Unregister msgUnregister = 8;
inline bool ContractIn::_internal_has_msgunregister() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || msgunregister_ != nullptr);
  return value;
}
inline bool ContractIn::has_msgunregister() const {
  return _internal_has_msgunregister();
}
inline void ContractIn::clear_msgunregister() {
  if (msgunregister_ != nullptr) msgunregister_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::contract_in::ContractIn_Unregister& ContractIn::_internal_msgunregister() const {
  const ::contract_in::ContractIn_Unregister* p = msgunregister_;
  return p != nullptr ? *p : *reinterpret_cast<const ::contract_in::ContractIn_Unregister*>(
      &::contract_in::_ContractIn_Unregister_default_instance_);
}
inline const ::contract_in::ContractIn_Unregister& ContractIn::msgunregister() const {
  // @@protoc_insertion_point(field_get:contract_in.ContractIn.msgUnregister)
  return _internal_msgunregister();
}
inline ::contract_in::ContractIn_Unregister* ContractIn::release_msgunregister() {
  // @@protoc_insertion_point(field_release:contract_in.ContractIn.msgUnregister)
  _has_bits_[0] &= ~0x00000010u;
  ::contract_in::ContractIn_Unregister* temp = msgunregister_;
  msgunregister_ = nullptr;
  return temp;
}
inline ::contract_in::ContractIn_Unregister* ContractIn::_internal_mutable_msgunregister() {
  _has_bits_[0] |= 0x00000010u;
  if (msgunregister_ == nullptr) {
    auto* p = CreateMaybeMessage<::contract_in::ContractIn_Unregister>(GetArenaNoVirtual());
    msgunregister_ = p;
  }
  return msgunregister_;
}
inline ::contract_in::ContractIn_Unregister* ContractIn::mutable_msgunregister() {
  // @@protoc_insertion_point(field_mutable:contract_in.ContractIn.msgUnregister)
  return _internal_mutable_msgunregister();
}
inline void ContractIn::set_allocated_msgunregister(::contract_in::ContractIn_Unregister* msgunregister) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete msgunregister_;
  }
  if (msgunregister) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      msgunregister = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, msgunregister, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  msgunregister_ = msgunregister;
  // @@protoc_insertion_point(field_set_allocated:contract_in.ContractIn.msgUnregister)
}

// optional .contract_in.ContractIn.Register msgRegister = 9;
inline bool ContractIn::_internal_has_msgregister() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || msgregister_ != nullptr);
  return value;
}
inline bool ContractIn::has_msgregister() const {
  return _internal_has_msgregister();
}
inline void ContractIn::clear_msgregister() {
  if (msgregister_ != nullptr) msgregister_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::contract_in::ContractIn_Register& ContractIn::_internal_msgregister() const {
  const ::contract_in::ContractIn_Register* p = msgregister_;
  return p != nullptr ? *p : *reinterpret_cast<const ::contract_in::ContractIn_Register*>(
      &::contract_in::_ContractIn_Register_default_instance_);
}
inline const ::contract_in::ContractIn_Register& ContractIn::msgregister() const {
  // @@protoc_insertion_point(field_get:contract_in.ContractIn.msgRegister)
  return _internal_msgregister();
}
inline ::contract_in::ContractIn_Register* ContractIn::release_msgregister() {
  // @@protoc_insertion_point(field_release:contract_in.ContractIn.msgRegister)
  _has_bits_[0] &= ~0x00000020u;
  ::contract_in::ContractIn_Register* temp = msgregister_;
  msgregister_ = nullptr;
  return temp;
}
inline ::contract_in::ContractIn_Register* ContractIn::_internal_mutable_msgregister() {
  _has_bits_[0] |= 0x00000020u;
  if (msgregister_ == nullptr) {
    auto* p = CreateMaybeMessage<::contract_in::ContractIn_Register>(GetArenaNoVirtual());
    msgregister_ = p;
  }
  return msgregister_;
}
inline ::contract_in::ContractIn_Register* ContractIn::mutable_msgregister() {
  // @@protoc_insertion_point(field_mutable:contract_in.ContractIn.msgRegister)
  return _internal_mutable_msgregister();
}
inline void ContractIn::set_allocated_msgregister(::contract_in::ContractIn_Register* msgregister) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete msgregister_;
  }
  if (msgregister) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      msgregister = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, msgregister, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  msgregister_ = msgregister;
  // @@protoc_insertion_point(field_set_allocated:contract_in.ContractIn.msgRegister)
}

// optional .contract_in.ContractIn.Telemetry msgTelemetry = 10;
inline bool ContractIn::_internal_has_msgtelemetry() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || msgtelemetry_ != nullptr);
  return value;
}
inline bool ContractIn::has_msgtelemetry() const {
  return _internal_has_msgtelemetry();
}
inline void ContractIn::clear_msgtelemetry() {
  if (msgtelemetry_ != nullptr) msgtelemetry_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::contract_in::ContractIn_Telemetry& ContractIn::_internal_msgtelemetry() const {
  const ::contract_in::ContractIn_Telemetry* p = msgtelemetry_;
  return p != nullptr ? *p : *reinterpret_cast<const ::contract_in::ContractIn_Telemetry*>(
      &::contract_in::_ContractIn_Telemetry_default_instance_);
}
inline const ::contract_in::ContractIn_Telemetry& ContractIn::msgtelemetry() const {
  // @@protoc_insertion_point(field_get:contract_in.ContractIn.msgTelemetry)
  return _internal_msgtelemetry();
}
inline ::contract_in::ContractIn_Telemetry* ContractIn::release_msgtelemetry() {
  // @@protoc_insertion_point(field_release:contract_in.ContractIn.msgTelemetry)
  _has_bits_[0] &= ~0x00000040u;
  ::contract_in::ContractIn_Telemetry* temp = msgtelemetry_;
  msgtelemetry_ = nullptr;
  return temp;
}
inline ::contract_in::ContractIn_Telemetry* ContractIn::_internal_mutable_msgtelemetry() {
  _has_bits_[0] |= 0x00000040u;
  if (msgtelemetry_ == nullptr) {
    auto* p = CreateMaybeMessage<::contract_in::ContractIn_Telemetry>(GetArenaNoVirtual());
    msgtelemetry_ = p;
  }
  return msgtelemetry_;
}
inline ::contract_in::ContractIn_Telemetry* ContractIn::mutable_msgtelemetry() {
  // @@protoc_insertion_point(field_mutable:contract_in.ContractIn.msgTelemetry)
  return _internal_mutable_msgtelemetry();
}
inline void ContractIn::set_allocated_msgtelemetry(::contract_in::ContractIn_Telemetry* msgtelemetry) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete msgtelemetry_;
  }
  if (msgtelemetry) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      msgtelemetry = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, msgtelemetry, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  msgtelemetry_ = msgtelemetry;
  // @@protoc_insertion_point(field_set_allocated:contract_in.ContractIn.msgTelemetry)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace contract_in

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::contract_in::ContractIn_ContractInPacket> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::contract_in::ContractIn_ContractInPacket>() {
  return ::contract_in::ContractIn_ContractInPacket_descriptor();
}
template <> struct is_proto_enum< ::contract_in::ContractIn_Event> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::contract_in::ContractIn_Event>() {
  return ::contract_in::ContractIn_Event_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_contract_5fin_2eproto
